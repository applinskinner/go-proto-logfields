// Code generated by protoc-gen-gogo.
// source: examples/service.proto
// DO NOT EDIT!

/*
Package example is a generated protocol buffer package.

It is generated from these files:
	examples/service.proto

It has these top-level messages:
	Note
	Request
	Response
*/
package example

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/improbable-io/go-proto-logfields"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

func (this *Note) textLogFields() []string {
	var vals []string
	for _, val := range this.Text {
		vals = append(vals, val)
	}
	return vals
}
func (this *Note) LogFields() map[string][]string {
	// Handle being called on nil message.
	if this == nil {
		return map[string][]string{}
	}
	// Generate fields for this message.
	return map[string][]string{
		"author": []string{this.Author},
		"note":   this.textLogFields(),
	}
}

func (this *Request) LogFields() map[string][]string {
	// Handle being called on nil message.
	if this == nil {
		return map[string][]string{}
	}
	// Gather fields from child messages.
	var hasInner bool
	noteFields := this.Note.LogFields()
	hasInner = hasInner || len(noteFields) > 0
	if !hasInner {
		// If no inner messages added any fields, the fields map is complete.
		return map[string][]string{
			"path": []string{this.Path},
		}
	}
	// Merge all the field maps.
	res := map[string][]string{}
	res["path"] = append(res["path"], this.Path)
	for k, v := range noteFields {
		res[k] = append(res[k], v...)
	}
	return res
}

func (this *Response) notesLogFields() map[string][]string {
	fields := map[string][]string{}
	for _, msg := range this.Notes {
		for k, v := range msg.LogFields() {
			fields[k] = append(fields[k], v...)
		}
	}
	return fields
}
func (this *Response) LogFields() map[string][]string {
	// Handle being called on nil message.
	if this == nil {
		return map[string][]string{}
	}
	// Gather fields from child messages.
	var hasInner bool
	changedNoteFields := this.ChangedNote.LogFields()
	hasInner = hasInner || len(changedNoteFields) > 0
	notesFields := this.notesLogFields()
	hasInner = hasInner || len(notesFields) > 0
	if !hasInner {
		// If no inner messages added any fields, the fields map is complete.
		return map[string][]string{
			"did_it": []string{fmt.Sprintf("%v", this.DidStuff)},
		}
	}
	// Merge all the field maps.
	res := map[string][]string{}
	res["did_it"] = append(res["did_it"], fmt.Sprintf("%v", this.DidStuff))
	for k, v := range changedNoteFields {
		res[k] = append(res[k], v...)
	}
	for k, v := range notesFields {
		res[k] = append(res[k], v...)
	}
	return res
}
