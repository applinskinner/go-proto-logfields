// Code generated by protoc-gen-gogo.
// source: examples/service.proto
// DO NOT EDIT!

/*
Package example is a generated protocol buffer package.

It is generated from these files:
	examples/service.proto

It has these top-level messages:
	Note
	Request
	Response
*/
package example

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/improbable-io/go-proto-logfields"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

func (this *Note) LogFields() map[string]string {
	// Handle being called on nil message.
	if this == nil {
		return map[string]string{}
	}
	// Generate fields for this message.
	fields := map[string]string{
		"note": this.Text,
	}
	return fields
}
func (this *Request) LogFields() map[string]string {
	// Handle being called on nil message.
	if this == nil {
		return map[string]string{}
	}
	// Generate fields for this message.
	fields := map[string]string{
		"path": this.Path,
	}
	return fields
}
func (this *Response) LogFields() map[string]string {
	// Handle being called on nil message.
	if this == nil {
		return map[string]string{}
	}
	// Gather fields from child messages.
	// subCount tracks the total number of fields, assuming no duplicates, to reduce allocations later.
	subCount := 0
	noteFields := this.Note.LogFields()
	subCount += len(noteFields)
	// Generate fields for this message.
	fields := map[string]string{
		"did_it": fmt.Sprintf("%v", this.DidStuff),
	}
	// If no inner messages added any fields, the fields map is complete.
	if subCount == 0 {
		return fields
	}
	// Merge all the field maps.
	res := make(map[string]string, subCount+len(fields))
	for k, v := range noteFields {
		res[k] = v
	}
	for k, v := range fields {
		res[k] = v
	}
	return res
}
